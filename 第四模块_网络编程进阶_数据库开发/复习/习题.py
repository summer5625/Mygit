# -*- coding: utf-8 -*-
# @Time    : 2019/7/27  11:06
# @Author  : XiaTian
# @File    : 习题.py



"""
1、简述计算机操作系统中的“中断”的作用？
    中断是程序在执行过程中遇到优先级非常高的程序，就会保存程序当前状态，立即终止现程序的运行，自动转入相应的处理程序，
    待处理完成后，再返回来接着执行。
    作用：提高了系统效率，维持系统可靠性和安全性，满足实时处理要求，提供故障现场处理手段。

2、简述计算机内存中的“内核态”和“用户态”；
    内核态：当一个程序因为系统调用陷入内核代码中执行时处于内核态，内核态程序可以访问CPU所有数据
    用户态：当一个进程执行用户自己的代码时处于用户态，用户态程序之内访问受限制的内存，且不允许访问外部设备，cpu资源可以被别的程序获取
    用户态的应用程序可以通过三种方式来访问内核态的资源：
        1）系统调用
        2）库函数
        3）Shell脚本
    用户态到内核态的切换:
        1.系统调用        用户程序主动发起的 软中断 os.fork() process
        2.异常            被动的   当CPU正在执行运行在用户态的程序时，突然发生某些预
3、什么是进程？
    进程是一个正在执行的过程或者程序

4、什么是线程？
    是操作系统能够进行运算调度的最小单位，是进程中的实际执行单位

4.1、进程线程区别？
    1、同一进程内的所有线程共享该进程的地址资源
    2、创建线程的开销远远小于创建进程

5、简述程序的执行过程；
    

6、什么是“系统调用”？
    运行于用户态，为应用程序员写的程序提供调用接口，本质是应用程序请求os内核完成某一功能时的一种过程调用，是通过中断实现的。

7、threading模块event和condition的区别；
    Event：是线程间通信的方式，相当于信号，一个线程可以给另外一个线程发送信号后让其执行
    Condition：可以再某些事件触发或者到达特定条件后才处理数据，使得线程等待，本质上是特殊的锁

8、进程间通信方式有哪些？
    1、管道：是一块共享的内存
    2、队列：是基于管道+锁实现的，只有一把锁，程序并发执行
    3、信号量：可以设置多把锁，多个进程可以同时运行，可以实现并行
    4、内存共享：效率低，需要自己加锁处理
    5、scoket套接字通信
    6、消息对列(用于多台机，大型通信)


9、简述你对管道、队列的理解；
    队列和管道都是通过一块共享的内存来实现进程之间通信的
    管道：只能是父子或者兄弟进程之间进行通信，数据只能在一个方向上流动，数据没有加锁处理不安全，数据不可反复读取了

    队列：是管道+锁实现的，可以认为是一个全局链表，可以实现不同进程间双向通信，存放的数据大小和数量都有限制，加锁处理数据更加安全
         队列是面向记录的，其中的消息具有特定的格式以及特定的优先级，消息队列可以实现消息随机查询。
         队列独立于发送与接收进程。进程终止时，消息队列及其内容不会被删除。
    
10、请简述你对join、daemon方法的理解，举出它们在生产环境中的使用场景；
    join：阻塞主进程，待子进程结束后在放开阻塞
        应用主进程执行到某一阶段后能够让主进程检测到子进程的运行是否完成，在继续执行环境
    daemon：主进程代码执行完成后守护进程就结束，守护进程内无法再开启子进程
            用于主进程执行不用检测子进程的状态，并且主进程执行完成后，子进程不用在进行执行的场景


11、请简述IO多路复用模型的工作原理；
    原理：通过select/epoll这个函数不断轮询所负责的所有套接字，当某个套接字有数据，就通知用户进程去操作数据

12、threading中Lock和RLock的相同点和不同点；
    Lock：一把锁，只能被获得一次
    RLock：一把锁，可以锁多次，每获得一次加1，释放一次减一

13、什么是select，请简述它的工作原理，简述它的优缺点；
    select是一个套接字的代理函数，select工作时会遍历它所监测的fd_set内的所有文件描述符，调用其对应的poll方法，然后返回一个bitmask告诉select
    当前资源哪些可用。当select循环遍历完所有fd_set内指定的文件描述符对应的poll函数后，如果没有一个资源可用(即没有一个文件可供操作)，
    则select让该进程睡眠，一直等到有资源可用为止，进程被唤醒(或者timeout)继续往下执行。
    优缺点：
    占用资源少，不消耗太多CPU，能同时为多个客户端服务，适用于多个连接
    代理套接字过多性能明显下降，效率变低，跨平台能力弱


14、什么是epoll，请简述它的工作原理，简述它的优缺点；
    原理：1、在调用epoll_create后，内核创建一个eventpoll红黑树结构和一个list双向链表，在内核态准备接受储存的需要监控的fd
         2、在调用epoll_ctr后，直接向内核态的eventpoll进行add/mod/del对应的fd
         3、在epoll_ctr执行的时候，除了会向eventpoll添加修改之外，还会在内核中断函数处理程序中注册一个回调函数，告诉内核，当
            这个fd就绪之后，将其放到list里面去
         4、在epoll_wait调用的时候，会遍历list中的数据，然后直接处理
    优点：不需要遍历整个对列，只需要遍历epoll_wait就绪对列；效率高，节省cpu开销

15、简述select和epoll的区别；
    select需要轮询整个代理的消息对列，当代理的数量过大时，轮询消耗时间就变长
    epoll不需要轮询所代理的消息对列，当代理的对列里面有数据准备好后，就会将其状态发送到就绪列表中，epoll只需要轮询就绪列表

16、简述多线程和多进程的使用场景；
    多线程用于I/O密集型
    多进程用于计算密集型

17、请分别简述threading.Condition、threading.event、threading.semaphore、的使用场景；
    Condition用于当线程运行到某一阶段时需要满足条件时才能继续执行场景
    Event用于当一个线程运行到某一阶段时需要获取到另外的线程的状态才能继续运行场景
    Semaphore用于需要多个线程同时运行


18、假设有一个名为threading_test.py的程序里有一个li = [1, 2, 3, 4]的列表，另有a，b两个函数分别往该列表中增加元素，
a函数需要修改li之前需要获得threading.Lock对象，b函数不需要，请问当线程t1执行a函数获取到Lock对象之后并没有release该对象的情况下，
线程t2执行b函是否可以修改li，为什么？
    可以修改，a,b两个线程在同一个进程里面运行的，同一进程里面的多个线程共享进程的内存空间


19、简述你对Python GIL的理解；
    GIL本质上是一把锁，它和其他锁不同的地方在于GIL是解释器级别的锁，所有线程在执行时都必须先拿到GIL锁才能执行，将程序变成串行执行

20、请列举你知道的线程间通信方式；
    event
    信号量
    互斥锁
    Condition

21、什么是同步I/O，什么是异步I/O？
    同步I/O：在做I/O操作时会将进程阻塞
    异步I/O：在做I/O操作时不会将进程阻塞

22、什么是管道，如果两个进程尝试从管道的同一端读写数据，会出现什么情况？
    管道：是特殊类型的文件，是进行进程间通信的特殊类型的文件，需要通信的两个进程在管道的两端，进程利用管道传递信息
    后读写的进程会将前面一个进程写入文件中的内容覆盖掉
    

23、为什么要使用线程池/进程池？
    因为使用的计算机内存的限制，同时开启的进程和线程不能无限大，开启的进程和线程过多会降低系统运行效率


24、如果多个线程都在等待同一个锁被释放，请问当该锁对象被释放的时候，哪一个线程将会获得该锁对象？
    排在前一个线程后面的线程先拿到锁


25、import threading;s = threading.Semaphore(value=-1)会出现什么情况？
    报错

26、请将二进制数10001001转化为十进制；
    int('10001001',2)=137

27、某进程在运行过程中需要等待从磁盘上读入数据，此时该进程的状态将发生什么变化？
    该进程将由运行态转变成阻塞态

28、请问selectors模块中DefaultSelector类的作用是什么；
    自动选择当前环境中最有效的selector

29、简述异步I/O的原理；
    异步I/O
    

30、请问multiprocessing模块中的Value、Array类的作用是什么？举例说明它们的使用场景
    Value、Array是用来进行进程间内存共享的
    Value是创建一个变量大小的共享内存，而Array则是创建一个数组大小的共享内存
    

31、请问multiprocessing模块中的Manager类的作用是什么？与Value和Array类相比，Manager的优缺点是什么？
    Manager类实现共享内存的，类似于服务器与客户之间的通信，Manager能共享字典和列表
    Manager 网络的方式，共享的数据类型多
    Value和Array共享内存
    可以通过使用Value或者Array把数据存储在一个共享的内存表中；
    Manager()返回一个manager类型，控制一个server process，可以允许其它进程通过代理复制一些python objects 
    Manager类的作用共享资源，manger的的优点是可以在pool进程池中使用，缺点是windows环境下性能比较差

32、请说说你对multiprocessing模块中的Queue().put(), Queue.put_nowait(), Queue.get(), Queue.get_nowait()的理解；
     Queue.put_nowait()如果队列满了会立即抛出异常
     Queue.get_nowait()如果队列空了会立即抛出异常
     Queue().put()和Queue.get()不会抛出异常，当队列满了或者空了会一直卡住直到队列有空或者队列有数据
     

33、什么是协程？使用协程与使用线程的区别是什么？
    协程是单线程下的并发，是一种用户态轻量级线程，由用户自己控制调度的。
    协程是用户自己控制调度的，线程是由操作系统内核控制调度的
    特点：
        协程切换开销小，属于程序级别的切换，单线程内就可以实现并发。最大限度的利用CPU
        但是无法利用多核，如果协程阻塞整个线程就会阻塞

34、asyncio的实现原理是什么？

"""""

"""
1、请写一个包含10个线程的程序，主线程必须等待每一个子线程执行完成之后才结束执行，每一个子线程执行的时候都需要打印当前线程名、
当前活跃线程数量以及当前线程名称；

2、请写一个包含10个线程的程序，并给每一个子线程都创建名为"name"的线程私有变量，变量值为“Alex”；

3、请使用协程写一个消费者生产者模型；

4、写一个程序，包含十个线程，子线程必须等待主线程sleep 10秒钟之后才执行，并打印当前时间；

5、写一个程序，包含十个线程，同时只能有五个子线程并行执行；

6、写一个程序 ，包含一个名为hello的函数，函数的功能是打印字符串“Hello, World!”，该函数必须在程序执行30秒之后才开始执行(不能使用time.sleep())；

7、写一个程序，利用queue实现进程间通信；

8、写一个程序，利用pipe实现进程间通信；

9、使用selectors模块创建一个处理客户端消息的服务器程序；

10、使用socketserver创建服务器程序时，如果使用fork或者线程服务器，一个潜在的问题是，恶意的程序可能会发送大量的请求导致服务器崩溃，
请写一个程序，避免此类问题；

11、请使用asyncio实现一个socket服务器端程序；
"""

"""
MySQL
1、数据库介绍、类型、特性
2、MySQL数据库安装、连接、启动、停止
3、表字段类型介绍、主键约束、表创建语句
4、常用增删改查语句、分组、聚合
5、外键管理、unique字段、表结构修改语法
6、跨表查询，inner join、left join、right join、full join语法
7、复杂SQL语句如group by、子查询、函数的使用
8、索引原理及作用、普通索引、多列索引、唯一索引、全文索引等
9、基于hash&b+树索引的实现原理，索引的优缺点剖析
10、事务原理，ACID特性，应用场景讲解
11、事务回滚
12、触发器的特性，应用场景
13、触发器的增删改查方法
14、存储过程的作用及应用场景
15、创建存储过程，参数传递，流程控制语句if\while\repeat\loop等，动态SQL的创建
16、视图的作用及使用场景，视图的增删改查
17、数据库权限管理，用户管理
18、数据库备份命令及工具讲解
19、基于不同业务的数据库表结构设计、性能优化案例
20、pymysql模块介绍和使用

"""

"""
1、说说你所知道的MySQL数据库存储引擎，InnoDB存储引擎和MyISM存储引擎的区别？
    主要有
    MyISM：MyISAM存储引擎：不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有要求或者以select，insert为主的应用
       基本上可以用这个引擎来创建表
    InnoDB：支持事务
    Memory：Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，
        因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。
    Merge：Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，
       删除操作，这些操作实际上是对内部的MyISAM表进行的。

    MyISM和InnoDB的区别
    InnoDB支持事务，而MyISM不支持事务
    InnoDB支持行级锁，而MyISM支持表级锁
    InnoDB支持外键，而MyISM不支持
    InnoDB支持全文索引，而MyISM不支持
    InnoDB是索引组织表，MyISM是堆表  (堆表的数据是随机插入的，索引组织表的数据是有序的)

2、MySQL中char和varchar的区别，varchar(50)和char(50)分别代表什么意思？
    char:定长  char(50)代表存储字符的长度是50
    varchar:变长 varchar(50)代表最多存储50个字符

3、MySQL中int类型存储多少个字节？
    int存储4字节，最小值-2147483648，最大值21477483647
    
4、主键具有什么特征？
    唯一且非空
    
5、简述你对inner join、left join、right join、full join的理解；
    inner join:只连接匹配行
    left join:左连接，优先显示左表的全部记录    
    right join:右连接，优先显示右表的全部记录
    full join:全外连接，显示两个表的全部记录
    
    
6、concat, group_concat函数的作用是什么？
    concat:作用是自定义查询后显示的格式，即将多个字符串拼接成一个字符串
    group_concat:作用是将分组后的每组数据内容显示出来


7、请介绍事务的实现原理；
    ACID:原子性，一致性，隔离性，持久性
    
8、索引的本质是什么？索引有什么优点，缺点是什么？
    索引是帮助MySQL高效获取数据的数据结构。因此，索引的本质是一种数据结构。
    在数据之外，数据库系统还可以维护满足特定查找算法的数据结构，这些数据结构以某种方式指向真实数据，这样就可以在这些数据结构上
    实现高级查找算法，这种数据结构就是索引。

    优点：
        1、提高数据检索效率，降低数据库的IO成本；
        2、通过索引对数据进行排序，降低了数据排序的成本，降低了CPU的利用率；

    缺点：
        1、索引实际上也是一张表，索引会占用一定的存储空间；
        2、更新数据表的数据时，需要同时维护索引表，因此，会降低insert、update 、delete的速度；
        
9、哪些情况下需要创建索引，哪些情况下不需要创建索引？
    1、主键自动创建唯一非空索引；
    2、频繁作为查询条件的字段应该创建索引；
    3、频繁更新的字段不适合简历索引，因为每次更新不仅仅更新数据表同时还会更新索引表；
    4、查询中经常排序的字段，可以考虑创建索引；
    5、如果某个字段的重复数据较多，不适合创建普通索引；
    
10、请分别介绍ACID代表的意思，什么业务场景需要支持事务，什么业务场景不需要支持事务？
    ACID分别代表事务的四种特性，分别是：
    原子性：即整体性和不可分割性，被认为是一个不可分割的单元，原子性执行是一个全部发生或者全部失败的过程。
    一致性：无论事务是成功还是失败，但是系统处于一致的状态，一致性保证数据库从不返回一个未处理事务
    隔离性：即每个事务在自己的隔离空间发生，与其他发生在系统中的事务隔离，而且事务的结果只有在完全被执行时才能看到
            当系统在多个用户同时连接时，系统必须遵守隔离性原则，保证事务与事务之间不会相互冲突。
    持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
    
    用于数据处理操作量大，复杂度高的场景

11、什么是触发器，请简述触发器的使用场景？
    触发器是一种特殊的存储过程，主要是通过对表的增、删、改操作触发而被执行，不是主动调用执行的
    用于监视表内的变化

12、什么是存储过程，存储过程的作用是什么？
    存储过程就是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。是为了完成特定功能的sql语句集合
    作用：封装重用sql语言代码，并给外部调用提供接口
    优点：存储过程可封装，并隐藏复杂的商业逻辑；存储过程可以回传值，并可以接受参数。
    存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同
    

13、什么是视图，简单介绍视图的作用和使用场景？
    视图是虚拟表，本质是根据sql语句获取动态数据集
    视图对sql语句进行了封装，提高了sql语句的安全性，减少重复sql语句的使用，提高开发效率。
    
    
14、如何查看SQL语句的执行计划？
    用explain+sql语句可以查看


15、在你本地数据库中查看select * from student的执行计划，并解释每个字段分别代表什么意思？
+----+-------------+----------+------+---------------+------+---------+------+------+-------+
| id | select_type | table    | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+----------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | EMPLOYEE | ALL  | NULL          | NULL | NULL    | NULL |   18 | NULL  |
+----+-------------+----------+------+---------------+------+---------+------+------+-------+
id : 查询标识符，数字越大越优先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。
   
select_type : 查询类型   
    A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个
    B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个
    C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union
    D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响
    E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null
    F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery
    G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响
    H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select
    
table : 查询的表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，
    如果显示为尖括号括起来的<derived N>就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。
    如果是尖括号括起来的<union M,N>，与<derived N>类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。
    

type : 连接类型，依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，
index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引。
    A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index
    B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描
    C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，
       唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref
    D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。
       或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。
    E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引
    F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。
    G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值
    H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。
    I：range：索引范围扫描，常见于使用>,<,is null,between ,in ,like等运算符的查询中。
    J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，
       官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range
    K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。
    L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。
    
possible_keys : 可能用到的索引 
 
key : 实际用的索引,select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个
  
key_len : 用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，
具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就
知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，
而排序和分组就算用到了索引，也不会计算到key_len中。

ref : 如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了
      表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func
rows : 这里是执行计划中估算的扫描行数，不是精确值

filtered : 根据查询条件过滤了百分多少的数据,使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，
不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，
不是具体记录数。

Extra : 附加信息
    A：distinct：在select部分使用了distinc关键字
    B：no tables used：不带from字句的查询或者From dual查询
    C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，
       反连接就是先查询外表，再查询内表。
    D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中
    E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。
    F：using join buffer（block nested loop），using join buffer（batched key accss）：
       5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。
    G：using sort_union，using_union，using intersect，using sort_intersection：
       using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集
       using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集
       using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，
       然后进行排序合并后，才能读取记录并返回。
    H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，
       used_tmp_table，used_tmp_disk_table才能看出来。
    I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，
       5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。
       5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎
       扫描的记录数量。extra列显示using index condition
    J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，
       就可能出现这个
    K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个

16、数据备份分为哪几种类型？增量备份和差异备份的区别是什么？
    完全备份：完全备份指的是备份整个数据集( 即整个数据库 )
    部分备份：部分备份指的是备份部分数据集(例如: 只备份一个表)，部分备份又分为增量备份和差异备份
    增量备份：增量备份指的是备份自上一次备份以来(增量或完全)以来变化的数据; 特点: 节约空间、还原麻烦
    差异备份：差异备份指的是备份自上一次完全备份以来变化的数据 特点: 浪费空间、还原比增量备份简单
    

17、请介绍select语句的执行顺序；
    首先执行from找到需要查询的表，第二需要连表的要执行on，根据后面的过滤条件来查找对应的数据，带上已执行添加外部行，即执行join确定连表的
    类型；第四执行where后面的过滤条件，第五执行group by语句来对符合where过滤条件的数据进行分组，第六执行having过滤条件，第六执行select
    关键字，找到需要查询的结果，第七执行distinct来对查询的结果进行去重，第八执行order by来对查找的结果进行排序，第九执行limit来确定查询
    结果打印的条数。
    

18、请问存储引擎MyISM和InnoDB的适合什么样的使用场景？
    MyISM：不支持事务和主键，索引，访问速度快，是堆表
    InnoDB：支持索引和事务，是索引组织表

19、请举出MySQL中常用的几种数据类型；
    整型：选择了整型后，其后面的长度不是表示整型数据的长度，而是其显示的长度，mysql中整型长度是固定的11位，其他数据类型后面的长度是表示最大长度
    浮点型:float  double  decimal  (float和double表示的小数点后最大位数都是30位，double的精度比float高，decimal由于是按照字符串存储的，
            表示的是小数的精确值，其整数部分和小数部分加起来最多能表示65位，小数部分最大能表示30位）
    字符类型：char  varchar
    日期类型：分为year(年)，time(时分秒)，date(年月日)，datetime(包含所有)
    枚举类型和集合类型

20、什么情况下会产生笛卡尔乘积，如何避免？
    SELECT * FROM 表名，表名会出现笛卡尔积(交叉相乘)

21、请列举MySQL中常用的函数；
    数学函数：
        ROUND(x,y):返回参数x的四舍五入的有y位小数的值
        ABS(x):求x的绝对值
        FLOOR(x):返回不大于x的整数值
        RAND():返回0到1内的随机值
        PI():返回圆周率值
        TRUNCATE(x,y):返回x，并保留y为小数
        SQRT(x):返回非负数x的二次方根
        AVG(col):返回指定列的平均值
        COUNT(col):返回指定列的不为空的个数
        MIN(col):返回指定列的最小值
        MAX(col):返回指定列的最大值
        SUM(col):返回指定列的所有值和
        GROUP_CONCAT(col):返回由属于一组的列值连接组合而成的结果    
    字符串函数：
        CHAR_LENGTH(str):返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符
        CONCAT(str1,str2,...):字符串拼接
        CONCAT_WS(separator,str1,str2,...):字符串拼接（自定义连接符）
        CONV(N,from_base,to_base):进制转换,如SELECT CONV('a',16,2); 表示将 a 由16进制转换为2进制字符串表示
        FORMAT(x,D)将数字x的格式写为'#,###,###.###'，以四舍五入的方式保留小数点后D位，并将结果以字符串形式返回
        INSERT(str,pos,len,newstr):在str的指定位置插入字符串 pos:要替换的位置，len:替换长度，newstr:新字符串
        UPPER:变大写
        UCASE:
        LEFT(str,len):返回字符串str从开始的len位置的子序列字符
        RTRIM
        SUBSTRING(str,pos),SUBSTRING(str FROM pos),SUBSTRING(str,pos,len),SUBSTRING(str FROM pos FOR len) 
            不带有len参数的格式从字符串str返回一个字符串，起始于位置pos。带有len的参数格式字符串str返回一个长度同len相同
            的字符串，起始于位置pos。使用FROM的格式为SQL的标准语法。也可能对pos使用一个负值，负值代表子字符串的位置起始于子字符串
            结尾的pos字符，而不是字符串的开头位置
        REVERSE
        FIELD
        LOCATE
        POSITION
        INSTR
    日期函数：
        CURDATE, CURRENT_DATE:返回当前的日期 
        CURTIME,CURRENT_TIME:返回当前的时间
        NOW():返回当前的时间和日期
        DATEDIFF
        ADDDATE
        SUBDATE
        QUARTER(date):返回当前日期的季度
        FROM_UNIXTIME(ts,fmt):根据指定的fmt格式，格式化ts的时间戳
        DAYOFYEAR(date):一年的第几天
    控制流函数：
        CASE WHEN[条件] THEN[结果]....ELSE[结果或者默认值]  END
            如果条件为真返回then后面结果，否则返回else后面结果
        CASE [条件一] WHEN [条件二] THEN [结果] ..... ELSE[结果] END
            如果条件一和条件二相等则返回then，否则返回else
        IF(test,t,f)  
            如果test为真，则返回他t，否则返回f
        IFNULL(arg1,arg2)
            如果arg1不为空，返回arg1，否则返回arg2
        NULLIF(arg1,arg2) 
            如果arg1=arg2返回NULL；否则返回arg1
    加密函数：
        MD5()    
            计算字符串str的MD5校验和
        PASSWORD(str)   
            返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。

22、请说明group by的使用场景；
    用于需要对表进行分组操作的场景

23、请介绍hash索引和B+树索引的实现原理；
    索引原理：本质都是通过不断缩小想要查找数据的范围来筛选出来最终想要的结果，同时把随机的事件变成顺序事件，也就是说有了索引我们总是可以
    用同一种方式来锁定数据。索引本质是数据结构
    
    哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，
    哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个
    数据行的指针。也就是说，由于哈希查找比起B-Tree索引，其本身对于单行查询的时间复杂度更低，有了哈希索引后明显可加快单行查询速度。

    但是哈希索引也有它自己的限制：
    哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况
    下这一点对性能的影响并不明显。哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
    哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列(A, B)上建立哈希索引，
    如果查询只有数据列A，则无法使用该索引。哈希索引只支持等值比较查询，包括=、in()、<=>。不支持任何范围查询，例如where price > 100。
    访问哈希索引的数据非常快，除非有很多哈希冲突。如果哈希冲突很多的话，一些索引维护操作的代价也很高。

    B+树索引是B树索引的变体，本质上也是多路平衡查找树
    B+树特点：数据项从左到右依次增大，非子叶节点的子树指针与关键字个数相同；内部节点并不存储真正的信息，而是保存其叶子节点的最小值作为索引
"""

"""
1、创建一个表student，包含ID(学生学号)，sname(学生姓名)，gender(性别)，credit(信用卡号),四个字段，要求：ID是主键，且值自动递增，
sname是可变长字符类型，gender是枚举类型, credit是可变长字符类型；

2、在上面的student表中增加一个名为class_id的外键，外键引用class表的cid字段；
    先建class表格，在向student表中增加class_id字段，然后在添加外键
    语法：
        alter table student add constraint foreign key(class_id) references class(cid);
        
3、向该表新增一条数据，ID为1，学生姓名为alex，性别女，修改ID为1的学生姓名为wupeiqi，删除该数据；
    
    
4、查询student表中，每个班级的学生数；

5、修改credit字段为unique属性；

6、请使用命令在你本地数据库中增加一个用户，并给该用户授予创建表的权限；

7、请使用pymsql模块连接你本地数据库，并向student表中插入一条数据；

8、请使用mysqldump命令备份student表；

9、创建一张名为student_insert_log的表，要求每次插入一条新数据到student表时，都向student_insert_log表中插入一条记录，记录student_id, insert_time;

10、创建一张名为student_update_log的表，要求每次更新student表中的记录时，都向student_update_log表中插入一条记录，记录student_id, update_time;
"""


import pymysql


conn = pymysql.connect(
    host = 'localhost',
    port = 3306,
    user = 'root',
    password = '123456',
    db = 'db1',
    charset = 'utf8'
)

courser = conn.cursor()
name = input('姓名:').strip()
gender = input('性别:').strip()
credit = input('credit:').strip()
class_id = input('班级:').strip()
sql = 'INSERT db1.student(sname,gender,credit,class_id) VALUES(%s,%s,%s,%s)'
courser.execute(sql,(name,gender,credit,class_id))

courser.execute('SELECT * FROM student',)
print(courser.fetchall())
conn.commit()
courser.close()
conn.close()
