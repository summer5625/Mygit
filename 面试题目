
############################################基础篇########################################################

1、简述解释型和编译型编程语言？
    编译型：应用源程序执行前，将程序源代码翻译成目标代码
        优点：可脱离语言环境独立执行，使用方便，程序执行效率高，不依赖编译器
        缺点：跨平台性能差，修改不方便
        举例：C  C++   Delpih

    解释型：应用程序源代码一边由相应语言的解释器翻译成目标代码，一边执行
        优点：跨平台性能好，修改方便
        缺点：效率低，程序执行不能脱离解释器

2、位和字节的关系？

    位：bit
    字节：bytes，缩写为B

    1B = 8bit

3、b、B、KB、MB、GB 的关系？

    1GB = 1024MB
    1MB = 1024KB
    1KB = 1024B
    1B = 8b

4、请至少列举5个 PEP8 规范（越多越好）

    每一级缩进使用4个空格。
    顶层函数和类的定义，前后用两个空行隔开。
    类里的方法定义用一个空行隔开。
    类名一般使用首字母大写的约定。
    函数名应该小写
    常量通常定义在模块级，通过下划线分隔的全大写字母命名

5、通过代码实现如下转换：

    二进制转换成十进制：v = “0b1111011”     int(v, 2)
    十进制转换成二进制：v = 18              bin(v)
    八进制转换成十进制：v = “011”           int(v, 8)
    十进制转换成八进制：v = 30              oct(v)
    十六进制转换成十进制：v = “0x12”        int(v, 16)
    十进制转换成十六进制：v = 87           hex(v)

6、请编写一个函数实现将IP地址转换成一个整数。

    如 10.3.9.12 转换规则为：
        10            00001010
          3            00000011 
         9            00001001
         12            00001100 
    再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？
    def transform(str):

    count = str.count('.')

    if count != 3:
        return 'ip不合法!'

    str_list = str.split('.')
    bin_list = []
    for i in str_list:

        binary = bin(int(i))
        binary = binary.split('b')[-1]

        if len(binary) < 8:

            long = '0' * (8 - len(binary)) + binary

        else:
            long = binary

        bin_list.append(long)

    long_bin = ''.join(bin_list)

    return int(long_bin, 2)



7、python递归的最大层数？

    默认最大1000次
    sys.setrecursionlimit(1500)可以修改最大递归层数


8、求结果：
    v1 = 1 or 3                        1
    v2 = 1 and 3                        3
    v3 = 0 and 2 and 1                  0
     v4 = 0 and 2 or 1                  1
     v5 = 0 and 2 or 1 or 4             1
     v6 = 0 or False and 1              False


9、ascii、unicode、utf-8、gbk 区别？

    ASCII码：最多只能用8位来表示（一个字节），即：2**8 = 256（即pow(2,8)=256），所以，ASCII码最多只能表示256个符号。
    unicode：万国码，任何一个字符==两个字节
    utf-8：万国码的升级版,一个中文字符==三个字节,英文是一个字节,欧洲的是2个字节
    gbk：国内版本,一个中文字符==2个字节,英文是一个字节

10、字节码和机器码的区别？

    机器码：机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到

    字节码：包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器
           转译后才能成为机器码的中间代码。

    字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。

11、三元运算规则以及应用场景？

     三元运算符就是在赋值变量的时候，可以直接加判断，然后赋值

    成立结果 if 条件 else 不成立结果


12、列举 Python2和Python3的区别？

        1、print

            在python2中，print被视为一个语句而不是一个函数，python3中，print()被视为一个函数

        2、整数的除法

            在python2中，键入的任何不带小数的数字，将被视为整数的编程类型。比如5/2=2，解决方法：5.0/2.0=2.5

            在python3中，整数除法变得更直观 5/2=2.5

         3、Unicode

            Python 2 默认使用 ASCII 字母表；Python 3 默认使用 Unicode

         4、后续发展

            Python 2.7 将在 2020 年失去后续的支持，

            Python 3 将继续开发更多的功能和修复更多的错误。


13、用一行代码实现数值交换： a = 1   b = 2？

    a, b = b, a


14、Python3和Python2中 int 和 long的区别？

    int(符号整数):通常被称为是整数或整数,没有小数点的正或负整数；

    long(长整数):无限大小的整数,这样写整数和一个大写或小写的L。

    python3中不再有long类型


15、xrange和range的区别？

    range: range([start], stop[, step]), 根据start与stop指定的范围以及step设定的步长，生成一个列表。

    xrange: xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器。

    1、range和xrange都是在循环中使用，输出结果一样。
    2、range返回的是一个list对象，而xrange返回的是一个生成器对象(xrange object)。
 　 3、xrange则不会直接生成一个list，而是每次调用返回其中的一个值，内存空间使用极少，因而性能非常好。
    4、python3中去掉了xrange，全部用range


16、文件操作时：xreadlines和readlines的区别？

    readlines： 返回的是一个列表: [‘第一行\n’, ‘第二行\n’, ‘第三行’]

    xreadlines： 返回的是一个生成器类型,python3已经没有改方法.


17、列举布尔值为False的常见值？

    0 , [ ] , " , ( ) , { }


18、字符串、列表、元组、字典每个常用的5个方法？

    字符串：


19、lambda表达式格式以及应用场景？


    匿名函数只能用于简单逻辑运算和三元运算
    lambda x,y:x*y


14、关于map函数：

    map(函数表达式， 可迭代对象)，得到一个可迭代对象


15、pass的作用？

    pass是空语句，是为了保持程序结构的完整性
    pass不做任何事情，一般用作占位语句


16、*arg和**kwarg作用？

    *arg和**kwarg用于处理当调用函数需要传入多个位置参数的情况

    *arg将多个位置参数转换成一个元组
    **kwarg转换成字典，传参形式必须为key=val，否则会报错


17、is和==的区别？

    is和==都用于比较判断

    ==是比较运算符，用来比较判断两个对象的值是否相等

    is是比较两个对象是不是完全相同，是不是同一个对象，占用的内存地址是否相同


18、简述Python的深浅拷贝以及应用场景？

      深拷贝是对于一个对象所有层次的拷贝
      浅拷贝是对于一个对象的顶层拷贝；通俗的理解是：拷贝了引用，并没有拷贝内容

      如果用浅拷贝、深拷贝对一个全部都是不可变类型的数据进行拷贝，那么它们结果相同，都是引用指向；

      如果拷贝的是一个拥有不可变类型的数据，即使元组是最顶层，那么deepcopy依然是深拷贝，而浅拷贝还是指向

      基本上只要不是我们自已手动调用的deepcopy方法都是浅拷贝，切片拷贝字典拷贝都是浅拷贝，而有些内置函数可以生成拷贝(list)，
      属于深拷贝:a = list(range(10))


19、Python垃圾回收机制？

    Python垃圾回收主要以引用计数为主，分代回收为辅。

    引用计数法的原理是每个对象维护一个ob_ref，用来记录当前对象被引用的次数，也就是来追踪到底有多少引用指向了这个对象，
    当发生以下四种情况的时候，该对象的引用计数器+1：
        1.对象被创建  a=14
        2.对象被引用  b=a
        3.对象被作为参数,传到函数中   func(a)
        4.对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}

    当发生以下四种情况时，该对象的引用计数器-1：
        1.当该对象的别名被显式销毁时  del a
        2.当该对象的引别名被赋予新的对象，   a=26
        3.一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
        4.将该元素从容器中删除时，或者容器被销毁时。

    当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁


20、Python的可变类型和不可变类型？

    不可变类型：一旦经过初始化创建成功，对应内存地址上的数据本身便不能发生任何变化
        数字  布尔  字符串  元组

    可变类型：经过初始化创建成功后，对应内存地址上的数据可以发生多次局部变化。

        列表  字典

21、求结果：
    v = dict.fromkeys(['k1','k2'],[]) 
   v[‘k1’].append(666)
    print(v)  {'k1': [666], 'k2': [666]}
   v[‘k1’] = 777
    print(v) {'k1': 777, 'k2': [666]}



22、求结果：

    def num():

        return [lambda x:i*x for i in range(4)]

    print([m(2) for m in num()])
    [6, 6, 6, 6]


23、列举常见的内置函数？


24、filter、map、reduce的作用？

    filter筛选符合条件的对象

    map

    reduce可以对可迭代对象进行累加，累乘操作

25、一行代码实现9*9乘法表？
    m = '\n'.join(['  '.join([ '%s * %s = %s' % (i, j ,i*j) for j in range(1, i+1)]) for i in range(1, 10)])


26、如何安装第三方模块？以及用过哪些第三方模块？

    1、通过python的pip命令自动进行第三方包安装

    2、自己下载地方包然后用pip命令进行安装


27、至少列举8个常用模块都有那些？

    time模块
    datetime模块
    logging模块
    random模块
    xml模块
    configparser模块
    hashlib模块
    re模块
    shelve模块
    os模块
    sys模块
    json模块
    pickle模块


28、re的match和search区别？

    match是匹配开头，匹配结果是一个对象，需要通过group取出匹配上的值，有group时匹配不上就报错

    search是匹配全部,只要找到第一个匹配就返回, 匹配结果是一个对象，需要通过group取出，有group时匹配不上就报错


29、什么是正则的贪婪匹配？

     贪婪匹配：在匹配字符串时总是尝试匹配尽可能多的字符。

     非谈贪婪配：在匹配字符串时总是尝试匹配尽可能少的字符。

     在贪婪匹配中在 * ？ + {m, n} 后面加上 ？ ，可使贪婪配变成非贪婪匹配


30、求结果：  a.[i % 2 for i in range(10)] b.(i % 2 for i in range(10))？

    [0, 1, 0, 1, 0, 1, 0, 1,0 1]
    生成器,可以用__next__()方法取出元素，但使用__next__()方法次数不能超过生成器的长度


31、求结果：  a. 1 or 2  b. 1 and 2  c. 1 < (2==2)  d. 1 < 2 == 2

    1 or 2            1
    1 and 2            2
    1 < (2==2)        False
    1 < 2 == 2        True


32、def func(a,b=[]) 这种写法有什么坑？

    第二个参数是非列表时，调用该参数时该参数时是传进来的数据类型


33、实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?
  
    '1,2,3'.split(',')


34、比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 c = [(1,),(2,),(3,) ] 的区别？

    打印时a和b打印结果一样都是一个列表输出，c是列表套元组结构

    a和b的元素都是整型，c是元组


35、如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?

    [ i*i for i in range(1, 11)]
    list(map(lambda x: x*x, range(1, 11)))


36、一行代码实现删除列表中重复的值 ?
    a = [1, 2, 3, 4, 2]
    list(set(a))


37、如何在函数中设置一个全局变量 ?

    global 变量名


38、logging模块的作用？以及应用场景？

    作用：用于记录日志，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。


39、请用代码简答实现stack 。

    stack堆栈：先进后出
    queue队列：先进先出

    注意：stack和queue是不能通过查询具体某一个位置的元素而进行操作的。但是他们的排列是按顺序的

    对于stack我们可以使用python内置的list实现，因为list是属于线性数组，在末尾插入和删除一个元素所使用的时间都是O(1),
    这非常符合stack的要求。当然，我们也可以使用链表来实现。
    class Stack:

    def __init__(self):

        self.stack = []

    def push(self, value):

        self.stack.append(value)

    def pop(self):

        if self.stack:
            self.stack.pop()
        else:
            raise LookupError('stack is empty!')

    def is_empty(self):

        return bool(self.stack)

    def top(self):

        return self.stack[-1]


40、常用字符串格式化哪几种？

    通过join
    通过format
    '%s-%s' % (1, 2)
    f'ffff plus {3+5}'


41、简述 生成器、迭代器、可迭代对象以及应用场景？

    生成器：按照某种算法不断生成新的数据，直到满足某一个指定的条件结束。
    主要应用用于“惰性”地生成一个无限序列

    列表生成式是直接创建一个新的list，它会一次性地把所有数据都存放到内存中，这会存在以下几个问题：
        1.内存容量有限，因此列表容量是有限的；
        2.当列表中的数据量很大时，会占用大量的内存空间，如果我们仅仅需要访问前面有限个元素时，就会造成内存资源的极大浪费；
        3.当数据量很大时，列表生成式的返回时间会很慢；

    生成器中的元素是按照指定的算法推算出来的，只有调用时才生成相应的数据。这样就不必一次性地把所有数据都生成，从而节省了大
    量的内存空间，这使得其生成的元素个数几乎是没有限制的，并且操作的返回时间也是非常快速的（仅仅是创建一个变量而已）。


    迭代器：以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。
    Iterator的计算是惰性的，只有通过next()函数时才会计算并返回下一个数据。



    可迭代对象：可直接用于for循环的对象统称为可迭代对象（Iterable）
    目前我们已经知道的可迭代（可用于for循环）的数据类型有：

        1.集合数据类型：如list、tuple、dict、set、str等
        2.生成器（Generator）


    生成器对象既是可迭代对象，也是迭代器
    迭代器对象一定是可迭代对象，反之则不一定

    迭代器、生成器和可迭代对象都可以用for循环去迭代，生成器和迭代器还可以被next()方函数调用并返回下一个值。


42、用Python实现一个二分查找的函数。

    def look(data, n):

    mid = int(len(data) / 2)

    if mid > 0:
        if data[mid] == n:

            print('找到了，索引为%s' % list(range(20)).index(n))

        elif data[mid] > n:

            print('没找到，中数%s比查找值%s大' % (data[mid], n))

            look(data[:mid], n)
        else:
            print('没找到，中数%s比查找值%s小' % (data[mid], n))

            look(data[mid:], n)


43、谈谈你对闭包的理解？

    闭包就是嵌套函数
    闭包就是：函数定义和函数表达式位于另一个函数的函数体内(嵌套函数)。而且，这些内部函数可以访问它们所在的外部函数
    中声明的所有局部变量、参数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包


44、os和sys模块的作用？

    os模块是提供了一种方便使用的操作系统函数的方法

    sys模块模块提供了可供解释器或维护变量和与解释器进行交互的函数

    os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;
    sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。


45、如何生成一个随机数？

    random.randint(0, 10)
    random.randrange(0, 10)


46、如何使用python删除一个文件？

    os.remove()          删一个文件
    os.removedirs()      删除空文件加


47、谈谈你对面向对象的理解？

    面向过程：核心“过程”，实质是将需要实现的功能分成多个功能段，然后在按照特定的顺序去执行这些功能段，从而实现要求功能
    优点：复杂问题流程化，将简单的问题简单化
    缺点：可扩展性差，维护难度会高
    用途：用于那些功能一旦实现之后就很少需要改变的场景，如，写一些简单的脚本程序


    对象：特征和技能集合的个体
    面向对象的核心是‘对象’；
    优点：使程序更加容易扩展和易更改，使开发效率变的更高；基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。
    缺点：过程复杂，极容易出现过度设计的问题
    用途：应用于客户需求经常变更，互联网应用，游戏等

    三大特性：封装 继承 多态


48、Python面向对象中的继承有什么特点？

    子类可以继承父类的所有属性和方法
    子类可以继承多个父类

49、面向对象深度优先和广度优先是什么？

    深度优先和广度优先是对多继承子类中，查找某一方法或属性时的查找顺


    深度优先：是沿着分支找，直到找到当前分支的顶层父类，在返回来查找下一个分支，最顶层的父类最先查找

    广度优先：优先是先查找某一个分支，遇到最顶层的父类停止，查找下一个分支，最顶层的父类最后查找


50、面向对象中super的作用？

    super是重用父类的方法，此方法依赖继承


51、是否使用过functools中的函数？其作用是什么？


52、面向对象中带双下划线的特殊方法，如：__new__、__init__

     __str__
     __bases__          查看继承的父类
     __getitem__        可通过设置该方法返回值，在实例化对象后，通过字典key-value形式获取返回的数据属性值
     __setitem__        设置对象的数据属性
     __delitem__        删除数据属性
     __del__            在程序结束后会自动触发，回收与对象相关的资源。
     __getattribute__   获取属性的值，不管属性是否存在都会执行，不会报错，当有返回值时，属性不存在，会一直循环查找，到了最大循环数即报错
     __get__()          调用一个属性时,触发
     __set__()          为一个属性赋值时,触发
     __delete__()       采用del删除属性时,触发


53、如何判断是函数还是方法？

    1.通过调用对应的方法或函数，看输出结果，结果有function的为函数，有bound的为方法

    2.看有没有通过@staticmethod装饰

    3、isinstance(work.show,FunctionType)和isinstance(Work.show,MethodType)查看


54、静态方法和类方法区别？

    实例方法由对象调用，至少一个self参数，self代表对象的引用。
    self指向当前的实例对象,所以只要该方法有self参数,在调用此方法的时候会先把这个对象的内存空间加载进来,以便在方法中使用该
    实例对象的属性或者方法

    类方法由类调用，至少一个cls参数，并且需要装饰器@classmethod修饰
    cls指向当前的类对象,类对象不等于实例对象,类对象和实例对象都有单独的内存空间存储,当调用一个含有@classmethod装饰的方法,
    则会先加载这个类的内存空间

    静态方法由类调用，不需要参数，需要装饰器@staticmethod修饰
    静态方法不需要使用实例对象的属性方法也不需要使用类对象的属性所有无论往静态方法中传一个self还是cls都会加载对应的资源,
    而静态方法又不使用,所有为了节省资源静态方法就应运而生.并且一直保存再来没有删除,尽管用到的次数很少.


55、列举面向对象中的特殊成员以及应用场景

    class Foo(object):
    def __init__(self, a1, a2):
        self.a1 = a1
        self.a2 = a2
    def __add__(self,other):
        return self.a1 + other.a2


56、1、2、3、4、5 能组成多少个互不相同且无重复的三位数

        10


57、什么是反射？以及应用场景？

    反射：通过字符串形式操作对象相关属性

    反射四方法：

        hasattr(object,name)                   判断对象中是否有对应的name方法或属性
        getattr(object, name, default=None)    得到对象中对应的name方法或属性
        setattr(x, y, v)                       给对象x设置y属性对应的函数或者值v
        delattr(x, y)                          删除x中的y方法或属性


    好处：
        可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用


58、metaclass作用？以及应用场景？

    创建类的三要素：类名  基类  作用域
    metaclass是指定类由谁创建的，它能够定制类的创建过程。



59、用尽量多的方法实现单例模式？

    单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。
    当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。

    1.使用导入的模块

    2.类实现

    3.元类实现


60、装饰器的写法以及应用场景。

    装饰器最大的作用就是对于我们已经写好的程序，我们可以抽离出一些雷同的代码组建多个特定功能的装饰器，
    这样我们就可以针对不同的需求去使用特定的装饰器，这时因为源码去除了大量泛化的内容而使得源码具有更加清晰的逻辑。

    user_state = False
    def login(func):

        def inner(*args, **kwargs):
            username = 'alex'
            password = '123'

            global user_state

            if user_state == False:
                user = input('账号:')
                pwd = input('密码:')

                if user == username and pwd == password:
                    user_state = True

            if user_state:
                func(*args, **kwargs)

        return inner



61、异常处理写法以及如何主动跑出异常（应用场景）

    1.遇到异常是可预知的，需要用if进行处理：在错误发生钱进行处理

    2.遇到错误是不可预知的，使用try except处理：在错误发生后处理
        try:
            被检测的代码块
        except 异常类型：
            try中一旦检测到异常，就执行这个位置的逻辑


62、什么是面向对象的mro？

    mro查看类的继承顺序,返回的是一个列表

    用法：类名.mro()


63、isinstance作用以及应用场景？

    isinstance作用：来判断一个对象是不是一个已知类型
    语法：isinstance(对象， 类型名称或者一个类型列表)


64、写一个，在列表中找到两个数字，使之相加等于给定的一个数，并返回这两个数的索引

    def result(arr, n):

        sum_list = []

        if not isinstance(arr, list):
            return 'ar是一个列表'

        for i in arr:
            li = arr.copy()
            li.remove(i)
            if (n - i) in li:

                m = [arr.index(i), arr.index(n-i)]
                m.sort()
                m = tuple(m)
                sum_list.append(m)

        sum_list = list(set(sum_list))

        return sum_list


65、json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？

   支持：int\str\list\tuple\dict类型

    import json
    from datetime import datetime, date


    class JsonDatetime(json.JSONEncoder):

        """
        JSONEncoder不知道怎么去把这个数据转换成json字符串的时候，
        它就会调用default()函数，default()函数默认会抛出异常。
        所以，重写default()函数来处理datetime类型的数据。

        """

        def default(self, o):

            if isinstance(o, datetime):
                return o.strftime('%Y-%m-%d %H:%M:%S')
            elif isinstance(o, date):
                return o.strftime('%Y-%m-%d')
            else:
                return json.JSONEncoder.default(self, o)


    d = {'name': 'ric', 'age': 18, 'data': datetime.now()}

    print(json.dumps(d, cls=JsonDatetime))



66、json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？

    在序列化时加上ensure_ascii=False
    json.dumps({'code':1 , 'msg':'成功退出'} , ensure_ascii=False)


67、什么是断言？应用场景？


68、有用过with statement吗？它的好处是什么？

    with语句使用所谓的上下文管理器对代码块进行包装，允许上下文管理器实现一些设置和清理操作。
    打开文件后会自动将文件关闭


69、使用代码实现查看列举目录下的所有文件。

    import os

    os.listdir()


70、简述 yield和yield from关键字。

    yield返回生成器的一条数据,只能在函数内部使用，包含yield语句的函数称为生成器函数
    如果遇到yield 语句，会挂起函数的运行状态，并将yield 右边的表达式的值返回给next()的调用者，
    挂起的时候会保存所有本地状态，包括局部变量，指令指针和内部堆栈信息，这样当下次再次调用next()时,
    看起来yield 部分就像是调用了一个外部调用一样，可以接着往下执行


    yield from用于生成器将其部分操作委托给另外一个生成器，这允许将包含yield的一段代码分解出来并放在另外一个生成器中，
    此外，允许子生成器返回一个值，这个值可供委派生成器使用

    关于yield from 六点重要的说明：

        1.子生成器产出的值都直接传给委派生成器的调用方(即客户端代码)

        2.使用send()方法发送给委派生成器的值都直接传给子生成器。如果发送的值为None,那么会给委派调用子生成器的__next__()方法。
          如果发送的值不是None,那么会调用子生成器的send方法，如果调用的方法抛出StopIteration异常，那么委派生成器恢复运行，任
          何其他异常都会向上冒泡，传给委派生成器

        3.生成器退出时，生成器(或子生成器)中的return expr表达式会出发StopIteration(expr)异常抛出

        4.yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数。yield from 结构的另外两个特性与异常和终止有关。

        5.传入委派生成器的异常，除了GeneratorExit之外都传给子生成器的throw()方法。如果调用throw()方法时抛出StopIteration异常，
          委派生成器恢复运行。StopIteration之外的异常会向上冒泡，传给委派生成器

        6.如果把GeneratorExit异常传入委派生成器，或者在委派生成器上调用close()方法，那么在子生成器上调用clsoe()方法，如果它有的话。
          如果调用close()方法导致异常抛出，那么异常会向上冒泡，传给委派生成器，否则委派生成器抛出GeneratorExit异常





#########################################网络编程和并发#########################################


1、简述 OSI 七层协议。

    osi七层模型包括：物理层 数据链路层 网络层 传输层 会话层 表示层 应用层


2、什么是C/S和B/S架构？

    C/S架构：C指的是客户端，S指的是服务端，C\S架构可以理解为客户端与服务端的通讯架构。


    B/S架构：B使之浏览器端，S指的是服务端，B/S架构是浏览器与服务端通讯的架构


3、简述 三次握手、四次挥手的流程。

    三次握手：
        第一次握手：客户端发送连接请求给服务端
        第二次握手：服务端收到客户端建立连接请求，并回给客户端发送确认信息
        第三次：客户端收到服务端确认信息建立连接，并向服务端再次发送确认信息

    四次挥手：
        第一次挥手：客户端发送断开连接请求
        第二次挥手：服务端收到客户端断开的请求，断开连接，发送确认信息
        第三次挥手：服务端给客户端数据发送完成后，发送断开连接请求给客户端
        第四次挥手：接收到这个断开请求对它进行确认。


4、什么是arp协议？

    ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。其作用是在以太网环境中，
    数据的传输所依懒的是MAC地址而非IP地址，而将已知IP地址转换为MAC地址的工作是由ARP协议来完成的。


5、TCP和UDP的区别？

    1.（基于连接vs无连接）tcp是面向连接的（三次握手；四次挥手）；udp不是面向连接的
    2.（重量级vs轻量级）tcp是一个重量级的协议；udp则是轻量级的协议。一个tcp数据报的报头大小最少20字节，udp数据报的包头固定8个字节
    3.（可靠性）tcp交付保证：如果消息在传输中丢失，那么它将重发；udp没有交付保证，一个数据包在运输过程中可能丢失。
    4.（有序性）消息到达网络的另一端可能是无序的，tcp协议将为你拍好序。Udp不提供任何有序性的保证。
    5.（速度）tcp慢，适合传输大量数据；udp快，适合传输少量数据。
    6.（流量控制和拥塞控制）TCP有流量控制和拥塞控制，udp没有。
    7.tcp面向字节流，udp面向报文
    8.tcp只能单播，不能发送广播和组播；udp可以广播和组播。


6、什么是局域网和广域网？

    局域网：（Local Area Network，LAN）， 是指在某一区域内由多台计算机互联成的计算机组。
    局域网是一个局部范围的计算计组，比如家庭网络就是一个小型的局域网，
    里面包含电脑、手机和平板等，他们共同连接到你家的路由器上。又比如学校的机房就是一个局域网，里面有几百几千台电脑，
    当机房无法上外网时，但是电脑之间仍可以通信，你们可以通过这个局域网来打CS 、玩红警。理论上，局域网是封闭的，并不可以上外网，
    可以只有两台电脑，也可以有上万台。

    广域网：（WAN，Wide Area Network），是一种跨越大的、地域性的计算机网络的集合
    广域网的范围就比较大了，可以把你家和别人家、各个省、各个国家连接起来相互通信。
    广域网和局域网都是从范围的角度来划分的，广域网也可以看成是很多个局域网通过路由器等相互连接起来。


7、为何基于tcp协议的通信比基于udp协议的通信更可靠？

    应为tcp协议的通信，咋建立连接时需要经过三次握手，如果对方没有响应连接则无法建立，也就无法进行通信

    udp协议视同过广播的形式进行通讯的


8、什么是socket？简述基于tcp协议的套接字通信流程。

    Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，
    它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。

    服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。
    在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。
    客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束


9、什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？

    同时执行多条命令之后，得到的结果很可能只有一部分，在执行其他命令的时候又接收到之前执行的另外一部分结果，这种显现就是黏包。


10、IO多路复用的作用？

    I/O多路复用是用于提升效率，单个进程可以同时监听多个网络连接IO






###################################数据库###################################


1、列举常见的关系型数据库和非关系型都有那些？

    关系型数据库：MySQL、db2、oracle、access、sql server、sqllite
    菲关系型：redis、MongoDB


2、MySQL常见数据库引擎及比较？

    InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。
    MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事物
    MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，
    不支持事务
    BLACKHOLE存储引擎接受但不存储数据，并且检索总是返回一个空集。


3、简述数据三大范式？

    1.第一范式：每一个分量必须是不可分的数据项。  特点：有主键，且主键不能为空。  字段不能再分。

    2.第二范式：在范式一的基础上，且每一个非主属性完全函数依赖于主键。  特点：满足第一范式。  表中的每一个非主属性，必须完全依赖于本表主键。
        只有当一个表中，主键由两个或以上的属性组成的时候，才会出现不符合第二范式的情况。

    3.第三范式：第二范式的基础上，且消除传递依赖性  特点：满足第二范式    所有的非主键列依赖于主键列


4、什么是事务？MySQL如何支持事务？

    事务用于将某些操作的多个SQL作为原子性操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据完整性。
    事务的四大特性：原子性、一致性、隔离性、持久性


5、简述数据库设计中一对多和多对多的应用场景？

    表关系是一对多，多对多或者一对一


6、如何基于数据库实现商城商品计数器？


7、MySQL索引种类

    普通索引：仅加速查询

    唯一索引：加速查询 + 列值唯一（可以有null）

    主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个

    组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

    全文索引：对文本的内容进行分词，进行搜索


8、索引在什么情况下遵循最左前缀的规则？





































